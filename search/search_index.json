{
    "docs": [
        {
            "location": "/", 
            "text": "referee-sinon\n\n\nSinon.JS assertions for the referee assertion library.\n\n\nUsage\n\n\nnpm install @sinonjs/referee-sinon --save-dev\n\n\n\n\nconst referee = require(\nreferee\n);\nconst sinon = require(\nsinon\n);\n\n// add the Sinon.JS assertions to referee\nrequire(\n@sinonjs/referee-sinon\n)(referee, sinon);\n\n\n\n\nAssertions\n\n\nThe descriptions are for \nassert\n, but the corresponding failure messages for \nrefute\n are also mentioned. For refute the behaviour is exactly opposite.\n\n\nOverview:\n\n\n\n\ncalled()\n\n\ncallCount()\n\n\ncallOrder()\n\n\ncalledOnce()\n\n\ncalledTwice()\n\n\ncalledThrice()\n\n\ncalledOn()\n\n\nalwaysCalledOn()\n\n\ncalledWith()\n\n\ncalledWithNew()\n\n\nalwaysCalledWith()\n\n\nalwaysCalledWithNew()\n\n\ncalledOnceWith()\n\n\ncalledWithExactly()\n\n\nalwaysCalledWithExactly()\n\n\nthrew()\n\n\nalwaysThrew()\n\n\n\n\ncalled()\n\n\nassert.called(spy)\n\n\n\n\nFails if the \nspy\n has never been called.\n\n\nvar spy = this.spy();\n\nassert.called(spy); // Fails\n\nspy();\nassert.called(spy); // Passes\n\nspy();\nassert.called(spy); // Passes\n\n\n\n\nMessages\n\n\nassert.called.message = \nExpected ${0} to be called at least once but was never called\n;\n\n\n\n\n\n    \n`${0}`:\n\n    \nThe spy\n\n\n\n\n\nrefute.called.message = \nExpected ${0} to not be called but was called ${1}${2}\n;\n\n\n\n\n\n    \n`${0}`:\n\n    \nThe spy\n\n    \n`${1}`:\n\n    \nThe number of calls as a string. Ex: \u201ctwo times\u201d\n\n    \n`${2}`:\n\n    \nAll calls formatted as a multi-line string\n\n\n\n\n\ncallCount()\n\n\nassert.callCount(spy, count)\n\n\n\n\nFails if the \nspy\n's \ncallCount\n property is not exactly \ncount\n\n\nvar spy = this.spy();\n\nassert.callCount(spy, 0); // Passes\nassert.callCount(spy, 1); // Fails\n\nspy();\nassert.callCount(spy, 0); // Fails\nassert.callCount(spy, 1); // Passes\n\n\n\n\nMessages\n\n\nassert.called.message = \nExpected ${spyObj} to be called exactly ${expectedTimes} times, but was called ${actualTimes}\n;\nrefute.called.message = \nExpected ${spyObj} to not be called exactly ${expectedTimes} times\n\n\n\n\n\n\n    \n`${spyObj}`:\n\n    \nThe spy\n\n    \n`${expectedTimes}`:\n\n    \nThe expected number of calls\n\n    \n`${actualTimes}`:\n\n    \nThe actual number of calls\n\n\n\n\n\ncallOrder()\n\n\nassert.callOrder(spy, spy2, ...)\n\n\n\n\nFails if the spies were not called in the specified order.\n\n\nvar spy1 = this.spy();\nvar spy2 = this.spy();\nvar spy3 = this.spy();\n\nspy1();\nspy2();\nspy3();\n\nassert.callOrder(spy1, spy3, spy2); // Fails\nassert.callOrder(spy1, spy2, spy3); // Passes\n\n\n\n\nMessages\n\n\nassert.callOrder.message = \nExpected ${expected} to be called in order but were called as ${actual}\n;\nrefute.callOrder.message = \nExpected ${expected} not to be called in order\n;\n\n\n\n\n\n    \n`${expected}`:\n\n    \nA string representation of the expected call order\n\n    \n`${actual}`:\n\n    \nA string representation of the actual call order\n\n\n\n\n\ncalledOnce()\n\n\nassert.calledOnce(spy)\n\n\n\n\nFails if the \nspy\n has never been called or if it was called more than once.\n\n\nvar spy = this.spy();\n\nassert.calledOnce(spy); // Fails\n\nspy();\nassert.calledOnce(spy); // Passes\n\nspy();\nassert.calledOnce(spy); // Fails\n\n\n\n\nMessages\n\n\nassert.calledOnce.message = \nExpected ${0} to be called once but was called ${1}${2}\n;\nrefute.calledOnce.message = \nExpected ${0} to not be called exactly once${2}\n;\n\n\n\n\n\n    \n`${0}`:\n\n    \nThe spy\n\n    \n`${1}`:\n\n    \nThe number of calls, as a string. Ex: \u201ctwo times\u201d\n\n    \n`${2}`:\n\n    \nThe call log. All calls as a string. Each line is one call and includes passed arguments, returned value and more\n\n\n\n\n\ncalledTwice()\n\n\nassert.calledTwice(spy)\n\n\n\n\nOnly passes if the \nspy\n was called exactly twice.\n\n\nvar spy = this.spy();\n\nassert.calledTwice(spy); // Fails\n\nspy();\nassert.calledTwice(spy); // Fails\n\nspy();\nassert.calledTwice(spy); // Passes\n\nspy();\nassert.calledTwice(spy); // Fails\n\n\n\n\nMessages\n\n\nassert.calledTwice.message = \nExpected ${0} to be called twice but was called ${1}${2}\n;\nrefute.calledTwice.message = \nExpected ${0} to not be called exactly twice${2}\n;\n\n\n\n\n\n    \n`${0}`:\n\n    \nThe spy\n\n    \n`${1}`:\n\n    \nThe number of calls, as a string. Ex: \u201ctwo times\u201d\n\n    \n`${2}`:\n\n    \nThe call log. All calls as a string. Each line is one call and includes passed arguments, returned value and more\n\n\n\n\n\ncalledThrice()\n\n\nassert.calledThrice(spy)\n\n\n\n\nOnly passes if the \nspy\n has been called exactly three times.\n\n\nvar spy = this.spy();\n\nassert.calledThrice(spy); // Fails\n\nspy();\nassert.calledThrice(spy); // Fails\n\nspy();\nassert.calledThrice(spy); // Fails\n\nspy();\nassert.calledThrice(spy); // Passes\n\nspy();\nassert.calledThrice(spy); // Fails\n\n\n\n\nMessages\n\n\nassert.calledThrice.message = \nExpected ${0} to be called thrice but was called ${1}${2}\n;\nrefute.calledThrice.message = \nExpected ${0} to not be called exactly thrice${2}\n;\n\n\n\n\n\n    \n`${0}`:\n\n    \nThe spy\n\n    \n`${1}`:\n\n    \nThe number of calls, as a string. Ex: \u201ctwo times\u201d\n\n    \n`${2}`:\n\n    \nThe call log. All calls as a string. Each line is one call and includes passed arguments, returned value and more\n\n\n\n\n\ncalledOn()\n\n\nassert.calledOn(spy, obj)\n\n\n\n\nPasses if the \nspy\n was called at least once with \nobj\n as its \nthis\n value.\n\n\nvar spy = this.spy();\nvar obj1 = {};\nvar obj2 = {};\nvar obj3 = {};\n\nspy.call(obj2);\nspy.call(obj3);\n\nassert.calledOn(spy, obj1); // Fails\nassert.calledOn(spy, obj2); // Passes\nassert.calledOn(spy, obj3); // Passes\n\n\n\n\nMessages\n\n\nassert.calledOn.message = \nExpected ${0} to be called with ${1} as this but was called on ${2}\n;\nrefute.calledOn.message = \nExpected ${0} not to be called with ${1} as this\n;\n\n\n\n\n\n    \n`${0}`:\n\n    \nThe spy\n\n    \n`${1}`:\n\n    \nThe object obj which is expected to have been this at least once\n\n    \n`${2}`:\n\n    \nList of objects which actually have been `this`\n\n\n\n\n\nalwaysCalledOn()\n\n\nassert.alwaysCalledOn(spy, obj)\n\n\n\n\nPasses if the \nspy\n was always called with \nobj\n as its \nthis\n value.\n\n\nvar spy1 = this.spy();\nvar spy2 = this.spy();\nvar obj1 = {};\nvar obj2 = {};\n\nspy1.call(obj1);\nspy1.call(obj2);\n\nspy2.call(obj2);\nspy2.call(obj2);\n\nassert.alwaysCalledOn(spy1, obj1); // Fails\nassert.alwaysCalledOn(spy1, obj2); // Fails\nassert.alwaysCalledOn(spy2, obj1); // Fails\nassert.alwaysCalledOn(spy2, obj2); // Passes\n\n\n\n\nMessages\n\n\nassert.alwaysCalledOn.message = \nExpected ${0} to always be called with ${1} as this but was called on ${2}\n;\nrefute.alwaysCalledOn.message = \nExpected ${0} not to always be called with ${1} as this\n;\n\n\n\n\n\n    \n`${0}`:\n\n    \nThe spy\n\n    \n`${1}`:\n\n    \nThe object obj which is expected always to have been `this`\n\n    \n`${2}`:\n\n    \nList of objects which actually have been `this`\n\n\n\n\n\ncalledWith()\n\n\nassert.calledWith(spy, arg1, arg2, ...)\n\n\n\n\nPasses if the \nspy\n was called at least once with the specified arguments. Other arguments may have been passed after the specified ones.\n\n\nvar spy = this.spy();\nvar arr = [1, 2, 3];\nspy(12);\nspy(42, 13);\nspy(\nHey\n, arr, 2);\n\nassert.calledWith(spy, 12);         // Passes\nassert.calledWith(spy, \nHey\n);      // Passes\nassert.calledWith(spy, \nHey\n, 12);  // Fails\nassert.calledWith(spy, \nHey\n, arr); // Passes\n\n\n\n\nMessages\n\n\nassert.calledWith.message = \nExpected ${0} to be called with arguments ${1}${2}\n;\nrefute.calledWith.message = \nExpected ${0} not to be called with arguments ${1}${2}\n;\n\n\n\n\n\n    \n`${0}`:\n\n    \nThe spy\n\n    \n`${1}`:\n\n    \nThe expected arguments\n\n    \n`${2}`:\n\n    \nString representation of all calls\n\n\n\n\n\ncalledWithNew()\n\n\nassert.calledWithNew(spy)\n\n\n\n\nFails if the \nspy\n has never called with \nnew\n.\n\n\nvar spy = this.spy();\n\nassert.calledWithNew(spy); // Fails\n\nnew spy();\nassert.calledWithNew(spy); // Passes\n\nspy();\nassert.calledWithNew(spy); // Passes\n\n\n\n\nMessages\n\n\nassert.calledWithNew.message = \nExpected ${spyObj} to be called with 'new' at least once but was never called with 'new'\n;\nrefute.calledWithNew.message = \nExpected ${spyObj} to not be called with 'new'\n;\n\n\n\n\n\n    \n`${spyObj}`:\n\n    \nThe spy\n\n\n\n\n\nalwaysCalledWith()\n\n\nassert.alwaysCalledWith(spy, arg1, arg2, ...)\n\n\n\n\nPasses if the \nspy\n was always called with the specified arguments. Other arguments may have been passed after the specified ones.\n\n\nvar spy = this.spy();\nvar arr = [1, 2, 3];\nspy(\nHey\n, arr, 12);\nspy(\nHey\n, arr, 13);\n\nassert.alwaysCalledWith(spy, \nHey\n);          // Passes\nassert.alwaysCalledWith(spy, \nHey\n, arr);     // Passes\nassert.alwaysCalledWith(spy, \nHey\n, arr, 12); // Fails\n\n\n\n\nMessages\n\n\nassert.alwaysCalledWith.message = \nExpected ${0} to always be called with arguments ${1}${2}\n;\nrefute.alwaysCalledWith.message = \nExpected ${0} not to always be called with arguments${1}${2}\n;\n\n\n\n\n\n    \n`${0}`:\n\n    \nThe spy\n\n    \n`${1}`:\n\n    \nThe expected arguments\n\n    \n`${2}`:\n\n    \nString representation of all calls\n\n\n\n\n\nalwaysCalledWithNew()\n\n\nassert.alwaysCalledWithNew(spy)\n\n\n\n\nPasses when the \nspy\n has was always called with \nnew\n\n\nvar spy = this.spy();\n\nassert.alwaysCalledWithNew(spy); // Fails\n\nnew spy();\nassert.alwaysCalledWithNew(spy); // Passes\n\nspy();\nassert.alwaysCalledWithNew(spy); // Fails\n\n\n\n\nMessages\n\n\nassert.calledWithNew.message = \nExpected ${spyObj} to always be called with 'new'\n;\nrefute.calledWithNew.message = \nExpected ${spyObj} to not always be called with 'new'\n;\n\n\n\n\n\n    \n`${spyObj}`:\n\n    \nThe spy\n\n\n\n\n\ncalledOnceWith()\n\n\nassert.calledOnceWith(spy, arg1, arg2, ...)\n\n\n\n\nPasses if the \nspy\n was called exactly once and with the specified arguments. Other arguments may have been passed after the specified ones.\n\n\nvar spy = this.spy();\nvar arr = [1, 2, 3];\nspy(12);\n\nassert.calledOnceWith(spy, 12);     // Passes\nassert.calledOnceWith(spy, 42);     // Fails\n\nspy(42, 13);\nassert.calledOnceWith(spy, 42, 13); // Fails\n\n\n\n\nMessages\n\n\nassert.calledOnceWith.message = \nExpected ${0} to be called once with arguments ${1}${2}\n;\nrefute.calledOnceWith.message = \nExpected ${0} not to be called once with arguments ${1}${2}\n;\n\n\n\n\n\n    \n`${0}`:\n\n    \nThe spy\n\n    \n`${1}`:\n\n    \nThe expected arguments\n\n    \n`${2}`:\n\n    \nString representation of all calls\n\n\n\n\n\ncalledWithExactly()\n\n\nassert.calledWithExactly(spy, arg1, arg2, ...)\n\n\n\n\nPasses if the \nspy\n was called at least once with exactly the arguments specified.\n\n\nvar spy = this.spy();\nvar arr = [1, 2, 3];\nspy(\nHey\n, arr, 12);\nspy(\nHey\n, arr, 13);\n\nassert.calledWithExactly(spy, \nHey\n, arr, 12); // Passes\nassert.calledWithExactly(spy, \nHey\n, arr, 13); // Passes\nassert.calledWithExactly(spy, \nHey\n, arr);     // Fails\nassert.calledWithExactly(spy, \nHey\n);          // Fails\n\n\n\n\nMessages\n\n\nassert.calledWithExactly.message = \nExpected ${0} to be called with exact arguments ${1}${2}\n;\nrefute.calledWithExactly.message = \nExpected ${0} not to be called with exact arguments${1}${2}\n;\n\n\n\n\n\n    \n`${0}`:\n\n    \nThe spy\n\n    \n`${1}`:\n\n    \nThe expected arguments\n\n    \n`${2}`:\n\n    \nString representation of all calls\n\n\n\n\n\nalwaysCalledWithExactly()\n\n\nassert.alwaysCalledWithExactly(spy, arg1, arg2, ...)\n\n\n\n\nPasses if the \nspy\n was always called with exactly the arguments specified.\n\n\nvar spy = this.spy();\nvar arr = [1, 2, 3];\nspy(\nHey\n, arr, 12);\n\nassert.alwaysCalledWithExactly(spy, \nHey\n, arr, 12); // Passes\nassert.alwaysCalledWithExactly(spy, \nHey\n, arr);     // Fails\nassert.alwaysCalledWithExactly(spy, \nHey\n);          // Fails\n\nspy(\nHey\n, arr, 13);\nassert.alwaysCalledWithExactly(spy, \nHey\n, arr, 12); // Fails\n\n\n\n\nMessages\n\n\nassert.alwaysCalledWithExactly.message = \nExpected ${0} to always be called with exact arguments ${1}${2}\n;\nrefute.alwaysCalledWithExactly.message = \nExpected ${0} not to always be called with exact arguments${1}${2}\n;\n\n\n\n\n\n    \n`${0}`:\n\n    \nThe spy\n\n    \n`${1}`:\n\n    \nThe expected arguments\n\n    \n`${2}`:\n\n    \nString representation of all calls\n\n\n\n\n\nthrew()\n\n\nassert.threw(spy[, exception])\n\n\n\n\nPasses if the \nspy\n threw at least once the specified \nexception\n. The \nexception\n can be a string denoting its type, or an actual object. If \nexception\n is not specified, the assertion passes if the \nspy\n ever threw any exception.\n\n\nvar exception1 = new TypeError();\nvar exception2 = new TypeError();\nvar exception3 = new TypeError();\nvar spy = this.spy(function(exception) {\n    throw exception;\n});\n\nfunction callAndCatchException(spy, exception) {\n    try {\n        spy(exception);\n    } catch(e) {\n    }\n}\n\ncallAndCatchException(spy, exception1);\ncallAndCatchException(spy, exception2);\n\nassert.threw(spy); // Passes\nassert.threw(spy, \u201cTypeError\u201d); // Passes\nassert.threw(spy, exception1); // Passes\nassert.threw(spy, exception2); // Passes\nassert.threw(spy, exception3); // Fails\n\ncallAndCatchException(spy, exception3); assert.threw(spy, exception3); // Passes\n\n\n\n\nMessages\n\n\nassert.threw.message = \nExpected ${0} to throw an exception${1}\n;\nrefute.threw.message = \nExpected ${0} not to throw an exception${1}\n;\n\n\n\n\n\n    \n`${0}`:\n\n    \nThe spy\n\n    \n`${1}`:\n\n    \nThe expected exception\n\n\n\n\n\nalwaysThrew()\n\n\nassert.alwaysThrew(spy[, exception])\n\n\n\n\nPasses if the \nspy\n always threw the specified \nexception\n. The \nexception\n can be a string denoting its type, or an actual object. If \nexception\n is not specified, the assertion passes if the \nspy\n ever threw any exception.\n\n\nvar exception1 = new TypeError();\nvar exception2 = new TypeError();\nvar spy = this.spy(function(exception) {\n    throw exception;\n});\n\nfunction callAndCatchException(spy, exception) {\n    try {\n        spy(exception);\n    } catch(e) {\n\n    }\n}\n\ncallAndCatchException(spy, exception1);\nassert.alwaysThrew(spy); // Passes\nassert.alwaysThrew(spy, \u201cTypeError\u201d); // Passes\nassert.alwaysThrew(spy, exception1); // Passes\n\ncallAndCatchException(spy, exception2);\nassert.alwaysThrew(spy); // Passes\nassert.alwaysThrew(spy, \u201cTypeError\u201d); // Passes\nassert.alwaysThrew(spy, exception1); // Fails\n\n\n\n\nMessages\n\n\nassert.alwaysThrew.message = \nExpected ${0} to always throw an exception${1}\n;\nrefute.alwaysThrew.message = \nExpected ${0} not to always throw an exception${1}\n;\n\n\n\n\n\n    \n`${0}`:\n\n    \nThe spy\n\n    \n`${1}`:\n\n    \nThe expected exception", 
            "title": "referee-sinon"
        }, 
        {
            "location": "/#referee-sinon", 
            "text": "Sinon.JS assertions for the referee assertion library.", 
            "title": "referee-sinon"
        }, 
        {
            "location": "/#usage", 
            "text": "npm install @sinonjs/referee-sinon --save-dev  const referee = require( referee );\nconst sinon = require( sinon );\n\n// add the Sinon.JS assertions to referee\nrequire( @sinonjs/referee-sinon )(referee, sinon);", 
            "title": "Usage"
        }, 
        {
            "location": "/#assertions", 
            "text": "The descriptions are for  assert , but the corresponding failure messages for  refute  are also mentioned. For refute the behaviour is exactly opposite.  Overview:   called()  callCount()  callOrder()  calledOnce()  calledTwice()  calledThrice()  calledOn()  alwaysCalledOn()  calledWith()  calledWithNew()  alwaysCalledWith()  alwaysCalledWithNew()  calledOnceWith()  calledWithExactly()  alwaysCalledWithExactly()  threw()  alwaysThrew()", 
            "title": "Assertions"
        }, 
        {
            "location": "/#called", 
            "text": "assert.called(spy)  Fails if the  spy  has never been called.  var spy = this.spy();\n\nassert.called(spy); // Fails\n\nspy();\nassert.called(spy); // Passes\n\nspy();\nassert.called(spy); // Passes", 
            "title": "called()"
        }, 
        {
            "location": "/#messages", 
            "text": "assert.called.message =  Expected ${0} to be called at least once but was never called ;  \n     `${0}`: \n     The spy   refute.called.message =  Expected ${0} to not be called but was called ${1}${2} ;  \n     `${0}`: \n     The spy \n     `${1}`: \n     The number of calls as a string. Ex: \u201ctwo times\u201d \n     `${2}`: \n     All calls formatted as a multi-line string", 
            "title": "Messages"
        }, 
        {
            "location": "/#callcount", 
            "text": "assert.callCount(spy, count)  Fails if the  spy 's  callCount  property is not exactly  count  var spy = this.spy();\n\nassert.callCount(spy, 0); // Passes\nassert.callCount(spy, 1); // Fails\n\nspy();\nassert.callCount(spy, 0); // Fails\nassert.callCount(spy, 1); // Passes", 
            "title": "callCount()"
        }, 
        {
            "location": "/#messages_1", 
            "text": "assert.called.message =  Expected ${spyObj} to be called exactly ${expectedTimes} times, but was called ${actualTimes} ;\nrefute.called.message =  Expected ${spyObj} to not be called exactly ${expectedTimes} times   \n     `${spyObj}`: \n     The spy \n     `${expectedTimes}`: \n     The expected number of calls \n     `${actualTimes}`: \n     The actual number of calls", 
            "title": "Messages"
        }, 
        {
            "location": "/#callorder", 
            "text": "assert.callOrder(spy, spy2, ...)  Fails if the spies were not called in the specified order.  var spy1 = this.spy();\nvar spy2 = this.spy();\nvar spy3 = this.spy();\n\nspy1();\nspy2();\nspy3();\n\nassert.callOrder(spy1, spy3, spy2); // Fails\nassert.callOrder(spy1, spy2, spy3); // Passes", 
            "title": "callOrder()"
        }, 
        {
            "location": "/#messages_2", 
            "text": "assert.callOrder.message =  Expected ${expected} to be called in order but were called as ${actual} ;\nrefute.callOrder.message =  Expected ${expected} not to be called in order ;  \n     `${expected}`: \n     A string representation of the expected call order \n     `${actual}`: \n     A string representation of the actual call order", 
            "title": "Messages"
        }, 
        {
            "location": "/#calledonce", 
            "text": "assert.calledOnce(spy)  Fails if the  spy  has never been called or if it was called more than once.  var spy = this.spy();\n\nassert.calledOnce(spy); // Fails\n\nspy();\nassert.calledOnce(spy); // Passes\n\nspy();\nassert.calledOnce(spy); // Fails", 
            "title": "calledOnce()"
        }, 
        {
            "location": "/#messages_3", 
            "text": "assert.calledOnce.message =  Expected ${0} to be called once but was called ${1}${2} ;\nrefute.calledOnce.message =  Expected ${0} to not be called exactly once${2} ;  \n     `${0}`: \n     The spy \n     `${1}`: \n     The number of calls, as a string. Ex: \u201ctwo times\u201d \n     `${2}`: \n     The call log. All calls as a string. Each line is one call and includes passed arguments, returned value and more", 
            "title": "Messages"
        }, 
        {
            "location": "/#calledtwice", 
            "text": "assert.calledTwice(spy)  Only passes if the  spy  was called exactly twice.  var spy = this.spy();\n\nassert.calledTwice(spy); // Fails\n\nspy();\nassert.calledTwice(spy); // Fails\n\nspy();\nassert.calledTwice(spy); // Passes\n\nspy();\nassert.calledTwice(spy); // Fails", 
            "title": "calledTwice()"
        }, 
        {
            "location": "/#messages_4", 
            "text": "assert.calledTwice.message =  Expected ${0} to be called twice but was called ${1}${2} ;\nrefute.calledTwice.message =  Expected ${0} to not be called exactly twice${2} ;  \n     `${0}`: \n     The spy \n     `${1}`: \n     The number of calls, as a string. Ex: \u201ctwo times\u201d \n     `${2}`: \n     The call log. All calls as a string. Each line is one call and includes passed arguments, returned value and more", 
            "title": "Messages"
        }, 
        {
            "location": "/#calledthrice", 
            "text": "assert.calledThrice(spy)  Only passes if the  spy  has been called exactly three times.  var spy = this.spy();\n\nassert.calledThrice(spy); // Fails\n\nspy();\nassert.calledThrice(spy); // Fails\n\nspy();\nassert.calledThrice(spy); // Fails\n\nspy();\nassert.calledThrice(spy); // Passes\n\nspy();\nassert.calledThrice(spy); // Fails", 
            "title": "calledThrice()"
        }, 
        {
            "location": "/#messages_5", 
            "text": "assert.calledThrice.message =  Expected ${0} to be called thrice but was called ${1}${2} ;\nrefute.calledThrice.message =  Expected ${0} to not be called exactly thrice${2} ;  \n     `${0}`: \n     The spy \n     `${1}`: \n     The number of calls, as a string. Ex: \u201ctwo times\u201d \n     `${2}`: \n     The call log. All calls as a string. Each line is one call and includes passed arguments, returned value and more", 
            "title": "Messages"
        }, 
        {
            "location": "/#calledon", 
            "text": "assert.calledOn(spy, obj)  Passes if the  spy  was called at least once with  obj  as its  this  value.  var spy = this.spy();\nvar obj1 = {};\nvar obj2 = {};\nvar obj3 = {};\n\nspy.call(obj2);\nspy.call(obj3);\n\nassert.calledOn(spy, obj1); // Fails\nassert.calledOn(spy, obj2); // Passes\nassert.calledOn(spy, obj3); // Passes", 
            "title": "calledOn()"
        }, 
        {
            "location": "/#messages_6", 
            "text": "assert.calledOn.message =  Expected ${0} to be called with ${1} as this but was called on ${2} ;\nrefute.calledOn.message =  Expected ${0} not to be called with ${1} as this ;  \n     `${0}`: \n     The spy \n     `${1}`: \n     The object obj which is expected to have been this at least once \n     `${2}`: \n     List of objects which actually have been `this`", 
            "title": "Messages"
        }, 
        {
            "location": "/#alwayscalledon", 
            "text": "assert.alwaysCalledOn(spy, obj)  Passes if the  spy  was always called with  obj  as its  this  value.  var spy1 = this.spy();\nvar spy2 = this.spy();\nvar obj1 = {};\nvar obj2 = {};\n\nspy1.call(obj1);\nspy1.call(obj2);\n\nspy2.call(obj2);\nspy2.call(obj2);\n\nassert.alwaysCalledOn(spy1, obj1); // Fails\nassert.alwaysCalledOn(spy1, obj2); // Fails\nassert.alwaysCalledOn(spy2, obj1); // Fails\nassert.alwaysCalledOn(spy2, obj2); // Passes", 
            "title": "alwaysCalledOn()"
        }, 
        {
            "location": "/#messages_7", 
            "text": "assert.alwaysCalledOn.message =  Expected ${0} to always be called with ${1} as this but was called on ${2} ;\nrefute.alwaysCalledOn.message =  Expected ${0} not to always be called with ${1} as this ;  \n     `${0}`: \n     The spy \n     `${1}`: \n     The object obj which is expected always to have been `this` \n     `${2}`: \n     List of objects which actually have been `this`", 
            "title": "Messages"
        }, 
        {
            "location": "/#calledwith", 
            "text": "assert.calledWith(spy, arg1, arg2, ...)  Passes if the  spy  was called at least once with the specified arguments. Other arguments may have been passed after the specified ones.  var spy = this.spy();\nvar arr = [1, 2, 3];\nspy(12);\nspy(42, 13);\nspy( Hey , arr, 2);\n\nassert.calledWith(spy, 12);         // Passes\nassert.calledWith(spy,  Hey );      // Passes\nassert.calledWith(spy,  Hey , 12);  // Fails\nassert.calledWith(spy,  Hey , arr); // Passes", 
            "title": "calledWith()"
        }, 
        {
            "location": "/#messages_8", 
            "text": "assert.calledWith.message =  Expected ${0} to be called with arguments ${1}${2} ;\nrefute.calledWith.message =  Expected ${0} not to be called with arguments ${1}${2} ;  \n     `${0}`: \n     The spy \n     `${1}`: \n     The expected arguments \n     `${2}`: \n     String representation of all calls", 
            "title": "Messages"
        }, 
        {
            "location": "/#calledwithnew", 
            "text": "assert.calledWithNew(spy)  Fails if the  spy  has never called with  new .  var spy = this.spy();\n\nassert.calledWithNew(spy); // Fails\n\nnew spy();\nassert.calledWithNew(spy); // Passes\n\nspy();\nassert.calledWithNew(spy); // Passes", 
            "title": "calledWithNew()"
        }, 
        {
            "location": "/#messages_9", 
            "text": "assert.calledWithNew.message =  Expected ${spyObj} to be called with 'new' at least once but was never called with 'new' ;\nrefute.calledWithNew.message =  Expected ${spyObj} to not be called with 'new' ;  \n     `${spyObj}`: \n     The spy", 
            "title": "Messages"
        }, 
        {
            "location": "/#alwayscalledwith", 
            "text": "assert.alwaysCalledWith(spy, arg1, arg2, ...)  Passes if the  spy  was always called with the specified arguments. Other arguments may have been passed after the specified ones.  var spy = this.spy();\nvar arr = [1, 2, 3];\nspy( Hey , arr, 12);\nspy( Hey , arr, 13);\n\nassert.alwaysCalledWith(spy,  Hey );          // Passes\nassert.alwaysCalledWith(spy,  Hey , arr);     // Passes\nassert.alwaysCalledWith(spy,  Hey , arr, 12); // Fails", 
            "title": "alwaysCalledWith()"
        }, 
        {
            "location": "/#messages_10", 
            "text": "assert.alwaysCalledWith.message =  Expected ${0} to always be called with arguments ${1}${2} ;\nrefute.alwaysCalledWith.message =  Expected ${0} not to always be called with arguments${1}${2} ;  \n     `${0}`: \n     The spy \n     `${1}`: \n     The expected arguments \n     `${2}`: \n     String representation of all calls", 
            "title": "Messages"
        }, 
        {
            "location": "/#alwayscalledwithnew", 
            "text": "assert.alwaysCalledWithNew(spy)  Passes when the  spy  has was always called with  new  var spy = this.spy();\n\nassert.alwaysCalledWithNew(spy); // Fails\n\nnew spy();\nassert.alwaysCalledWithNew(spy); // Passes\n\nspy();\nassert.alwaysCalledWithNew(spy); // Fails", 
            "title": "alwaysCalledWithNew()"
        }, 
        {
            "location": "/#messages_11", 
            "text": "assert.calledWithNew.message =  Expected ${spyObj} to always be called with 'new' ;\nrefute.calledWithNew.message =  Expected ${spyObj} to not always be called with 'new' ;  \n     `${spyObj}`: \n     The spy", 
            "title": "Messages"
        }, 
        {
            "location": "/#calledoncewith", 
            "text": "assert.calledOnceWith(spy, arg1, arg2, ...)  Passes if the  spy  was called exactly once and with the specified arguments. Other arguments may have been passed after the specified ones.  var spy = this.spy();\nvar arr = [1, 2, 3];\nspy(12);\n\nassert.calledOnceWith(spy, 12);     // Passes\nassert.calledOnceWith(spy, 42);     // Fails\n\nspy(42, 13);\nassert.calledOnceWith(spy, 42, 13); // Fails", 
            "title": "calledOnceWith()"
        }, 
        {
            "location": "/#messages_12", 
            "text": "assert.calledOnceWith.message =  Expected ${0} to be called once with arguments ${1}${2} ;\nrefute.calledOnceWith.message =  Expected ${0} not to be called once with arguments ${1}${2} ;  \n     `${0}`: \n     The spy \n     `${1}`: \n     The expected arguments \n     `${2}`: \n     String representation of all calls", 
            "title": "Messages"
        }, 
        {
            "location": "/#calledwithexactly", 
            "text": "assert.calledWithExactly(spy, arg1, arg2, ...)  Passes if the  spy  was called at least once with exactly the arguments specified.  var spy = this.spy();\nvar arr = [1, 2, 3];\nspy( Hey , arr, 12);\nspy( Hey , arr, 13);\n\nassert.calledWithExactly(spy,  Hey , arr, 12); // Passes\nassert.calledWithExactly(spy,  Hey , arr, 13); // Passes\nassert.calledWithExactly(spy,  Hey , arr);     // Fails\nassert.calledWithExactly(spy,  Hey );          // Fails", 
            "title": "calledWithExactly()"
        }, 
        {
            "location": "/#messages_13", 
            "text": "assert.calledWithExactly.message =  Expected ${0} to be called with exact arguments ${1}${2} ;\nrefute.calledWithExactly.message =  Expected ${0} not to be called with exact arguments${1}${2} ;  \n     `${0}`: \n     The spy \n     `${1}`: \n     The expected arguments \n     `${2}`: \n     String representation of all calls", 
            "title": "Messages"
        }, 
        {
            "location": "/#alwayscalledwithexactly", 
            "text": "assert.alwaysCalledWithExactly(spy, arg1, arg2, ...)  Passes if the  spy  was always called with exactly the arguments specified.  var spy = this.spy();\nvar arr = [1, 2, 3];\nspy( Hey , arr, 12);\n\nassert.alwaysCalledWithExactly(spy,  Hey , arr, 12); // Passes\nassert.alwaysCalledWithExactly(spy,  Hey , arr);     // Fails\nassert.alwaysCalledWithExactly(spy,  Hey );          // Fails\n\nspy( Hey , arr, 13);\nassert.alwaysCalledWithExactly(spy,  Hey , arr, 12); // Fails", 
            "title": "alwaysCalledWithExactly()"
        }, 
        {
            "location": "/#messages_14", 
            "text": "assert.alwaysCalledWithExactly.message =  Expected ${0} to always be called with exact arguments ${1}${2} ;\nrefute.alwaysCalledWithExactly.message =  Expected ${0} not to always be called with exact arguments${1}${2} ;  \n     `${0}`: \n     The spy \n     `${1}`: \n     The expected arguments \n     `${2}`: \n     String representation of all calls", 
            "title": "Messages"
        }, 
        {
            "location": "/#threw", 
            "text": "assert.threw(spy[, exception])  Passes if the  spy  threw at least once the specified  exception . The  exception  can be a string denoting its type, or an actual object. If  exception  is not specified, the assertion passes if the  spy  ever threw any exception.  var exception1 = new TypeError();\nvar exception2 = new TypeError();\nvar exception3 = new TypeError();\nvar spy = this.spy(function(exception) {\n    throw exception;\n});\n\nfunction callAndCatchException(spy, exception) {\n    try {\n        spy(exception);\n    } catch(e) {\n    }\n}\n\ncallAndCatchException(spy, exception1);\ncallAndCatchException(spy, exception2);\n\nassert.threw(spy); // Passes\nassert.threw(spy, \u201cTypeError\u201d); // Passes\nassert.threw(spy, exception1); // Passes\nassert.threw(spy, exception2); // Passes\nassert.threw(spy, exception3); // Fails\n\ncallAndCatchException(spy, exception3); assert.threw(spy, exception3); // Passes", 
            "title": "threw()"
        }, 
        {
            "location": "/#messages_15", 
            "text": "assert.threw.message =  Expected ${0} to throw an exception${1} ;\nrefute.threw.message =  Expected ${0} not to throw an exception${1} ;  \n     `${0}`: \n     The spy \n     `${1}`: \n     The expected exception", 
            "title": "Messages"
        }, 
        {
            "location": "/#alwaysthrew", 
            "text": "assert.alwaysThrew(spy[, exception])  Passes if the  spy  always threw the specified  exception . The  exception  can be a string denoting its type, or an actual object. If  exception  is not specified, the assertion passes if the  spy  ever threw any exception.  var exception1 = new TypeError();\nvar exception2 = new TypeError();\nvar spy = this.spy(function(exception) {\n    throw exception;\n});\n\nfunction callAndCatchException(spy, exception) {\n    try {\n        spy(exception);\n    } catch(e) {\n\n    }\n}\n\ncallAndCatchException(spy, exception1);\nassert.alwaysThrew(spy); // Passes\nassert.alwaysThrew(spy, \u201cTypeError\u201d); // Passes\nassert.alwaysThrew(spy, exception1); // Passes\n\ncallAndCatchException(spy, exception2);\nassert.alwaysThrew(spy); // Passes\nassert.alwaysThrew(spy, \u201cTypeError\u201d); // Passes\nassert.alwaysThrew(spy, exception1); // Fails", 
            "title": "alwaysThrew()"
        }, 
        {
            "location": "/#messages_16", 
            "text": "assert.alwaysThrew.message =  Expected ${0} to always throw an exception${1} ;\nrefute.alwaysThrew.message =  Expected ${0} not to always throw an exception${1} ;  \n     `${0}`: \n     The spy \n     `${1}`: \n     The expected exception", 
            "title": "Messages"
        }
    ]
}